@page "/"
@using AIForEverything.Services
@using Microsoft.JSInterop
@using Microsoft.SemanticKernel.ChatCompletion
@using Markdig
@inject IAIChatService ChatService
@inject ILogger<Chat> Logger
@inject IJSRuntime JS
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>AI Assistant</PageTitle>

<div class="chat-container">
    <header class="chat-header">
        <div class="header-content">
            <h1>AI Assistant</h1>
            <p class="subtitle">Your intelligent companion</p>
        </div>
    </header>
    
    <div class="chat-history" @ref="chatHistoryDiv">
        @foreach (var message in ChatService.GetChatHistory())
        {
            <div class="message @(message.Role.ToString().ToLower())">
                @if (message.Role == AuthorRole.Assistant)
                {
                    <div class="avatar">AI</div>
                }
                <div class="message-content">
                    <p>@((MarkupString)ConvertToHtml(message.Content))</p>
                </div>
                @if (message.Role == AuthorRole.User)
                {
                    <div class="avatar">User</div>
                }
            </div>
        }
        @if (isStreaming)
        {
            <div class="message assistant">
                <div class="avatar">AI</div>
                <div class="message-content">
                    <p>@((MarkupString)ConvertToHtml(currentStreamingMessage))</p>
                </div>
            </div>
        }
    </div>

    <div class="chat-input-container">
        <div class="input-wrapper">
            <input type="text" 
                   placeholder="Message AI Assistant..." 
                   @bind="userInput" 
                   @onkeyup="HandleKeyPress" />
            <button type="button" class="send-button" @onclick="SendMessage">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            @if (showToast)
            {
                <div class="toast @(isError ? "error" : "info") @(showToast ? "show" : "")">
                    <div class="toast-content">
                        <span class="toast-icon">
                            @if (isError)
                            {
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2"/>
                                    <path d="M12 8V12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                    <circle cx="12" cy="16" r="1" fill="currentColor"/>
                                </svg>
                            }
                            else
                            {
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2"/>
                                    <path d="M12 16V16.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                    <path d="M12 8V12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                </svg>
                            }
                        </span>
                        <span class="toast-message">@toastMessage</span>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private string userInput = "";
    private string currentStreamingMessage = "";
    private bool isStreaming = false;
    private ElementReference chatHistoryDiv;
    private CancellationTokenSource? cts;
    private bool isJsInteropReady;
    
    private bool showToast = false;
    private string toastMessage = "";
    private bool isError = false;
    private System.Threading.Timer? toastTimer;
    
    private static readonly MarkdownPipeline pipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    private string ConvertToHtml(string markdown)
    {
        if (string.IsNullOrEmpty(markdown)) return "";
        return Markdown.ToHtml(markdown, pipeline);
    }

    private void ShowToast(string message, bool error = false, int duration = 3000)
    {
        toastMessage = message;
        isError = error;
        showToast = true;
        StateHasChanged();

        toastTimer?.Dispose();
        toastTimer = new System.Threading.Timer(_ =>
        {
            InvokeAsync(() =>
            {
                showToast = false;
                StateHasChanged();
            });
        }, null, duration, Timeout.Infinite);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isJsInteropReady = true;
            await ScrollToBottom();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput))
        {
            ShowToast("Please enter a message", true);
            return;
        }

        if (isStreaming)
        {
            ShowToast("Please wait for the AI to finish responding", true);
            return;
        }

        var userMessage = userInput;
        
        userInput = "";
        
        StateHasChanged();
        if (isJsInteropReady)
        {
            await ScrollToBottom();
        }

        // Start streaming AI response
        isStreaming = true;
        currentStreamingMessage = "";
        
        try
        {
            cts = new CancellationTokenSource();
            
            await foreach (var chunk in ChatService.GetStreamingChatResponseAsync(userMessage).WithCancellation(cts.Token))
            {
                currentStreamingMessage += chunk;
                StateHasChanged();
                if (isJsInteropReady)
                {
                    await ScrollToBottom();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during AI response streaming");
            ShowToast("An error occurred while getting the AI response", true);
        }
        finally
        {
            isStreaming = false;
            currentStreamingMessage = "";
            StateHasChanged();
            if (isJsInteropReady)
            {
                await ScrollToBottom();
            }
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            if (chatHistoryDiv.Context != null)
            {
                await JS.InvokeVoidAsync("scrollToBottom", chatHistoryDiv);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error scrolling to bottom");
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (cts != null)
        {
            cts.Cancel();
            cts.Dispose();
        }
        toastTimer?.Dispose();
    }
} 